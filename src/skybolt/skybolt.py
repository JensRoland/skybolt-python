"""
Skybolt - High-performance asset caching for multi-page applications

Reads the render-map.json generated by @skybolt/vite-plugin and outputs
optimized HTML tags with intelligent caching via Service Workers.
"""

from __future__ import annotations

import json
from html import escape
from pathlib import Path
from typing import Any

from .cache_digest import CacheDigest


class Skybolt:
    """
    Skybolt asset renderer.

    Reads the render-map.json generated by @skybolt/vite-plugin and outputs
    optimized HTML tags with intelligent caching via Service Workers.
    """

    VERSION = "3.4.0"

    def __init__(
        self,
        render_map_path: str | Path,
        cookies: dict[str, str] | None = None,
        cdn_url: str | None = None,
    ) -> None:
        """
        Create a new Skybolt instance.

        Args:
            render_map_path: Path to render-map.json generated by Vite plugin
            cookies: Cookie dictionary (defaults to empty dict)
            cdn_url: Optional CDN URL prefix (e.g., 'https://cdn.example.com')

        Raises:
            FileNotFoundError: If render map cannot be read
            json.JSONDecodeError: If render map contains invalid JSON
        """
        render_map_path = Path(render_map_path)
        self._map: dict[str, Any] = json.loads(render_map_path.read_text())
        self._cdn_url = cdn_url.rstrip("/") if cdn_url else None

        # Parse Cache Digest from sb_digest cookie
        self._cache_digest = CacheDigest.from_base64((cookies or {}).get("sb_digest", ""))

    def css(self, entry: str, async_load: bool = False) -> str:
        """
        Render CSS asset.

        On first visit: inlines CSS with sb-* attributes for caching
        On repeat visit: outputs <link> tag (Service Worker serves from cache)

        Args:
            entry: Source file path (e.g., 'src/css/main.css')
            async_load: Load CSS asynchronously (non-render-blocking)

        Returns:
            HTML string
        """
        asset = self._map.get("assets", {}).get(entry)

        if asset is None:
            return self._comment(f"Skybolt: asset not found: {entry}")

        url = self._resolve_url(asset["url"])

        # Client has current version - external link (SW serves from cache)
        if self._has_cached(entry, asset["hash"]):
            if async_load:
                # Preload + onload swap for non-blocking load
                return (
                    f'<link rel="preload" href="{escape(url)}" as="style" onload="this.rel=\'stylesheet\'">'
                    f'<noscript><link rel="stylesheet" href="{escape(url)}"></noscript>'
                )
            return f'<link rel="stylesheet" href="{escape(url)}">'

        # First visit - inline with cache attributes
        if async_load:
            # media="print" trick: browser parses but doesn't apply until onload swaps to "all"
            return (
                f'<style media="print" onload="this.media=\'all\'"'
                f' sb-asset="{escape(entry)}:{escape(asset["hash"])}"'
                f' sb-url="{escape(url)}">'
                f'{asset["content"]}'
                f'</style>'
            )

        return (
            f'<style'
            f' sb-asset="{escape(entry)}:{escape(asset["hash"])}"'
            f' sb-url="{escape(url)}">'
            f'{asset["content"]}'
            f'</style>'
        )

    def script(self, entry: str, module: bool = True) -> str:
        """
        Render JavaScript asset.

        On first visit: inlines JS with sb-* attributes for caching
        On repeat visit: outputs <script> tag (Service Worker serves from cache)

        Args:
            entry: Source file path (e.g., 'src/js/app.js')
            module: Whether to load as ES module (default: True)

        Returns:
            HTML string
        """
        asset = self._map.get("assets", {}).get(entry)

        if asset is None:
            return self._comment(f"Skybolt: asset not found: {entry}")

        url = self._resolve_url(asset["url"])
        type_attr = ' type="module"' if module else ""

        # Client has current version - external script (SW serves from cache)
        if self._has_cached(entry, asset["hash"]):
            return f'<script{type_attr} src="{escape(url)}"></script>'

        # First visit - inline with cache attributes
        return (
            f'<script{type_attr}'
            f' sb-asset="{escape(entry)}:{escape(asset["hash"])}"'
            f' sb-url="{escape(url)}">'
            f'{asset["content"]}'
            f'</script>'
        )

    def preload(
        self,
        entry: str,
        as_type: str,
        mime_type: str | None = None,
        crossorigin: str | None = None,
        fetchpriority: str | None = None,
    ) -> str:
        """
        Render preload link for critical resources.

        Use this for fonts, images, or other resources that should load early.
        Preloaded resources are not cached by Skybolt's Service Worker.

        Args:
            entry: Source file path or direct URL
            as_type: Resource type ('image', 'font', 'style', 'script', 'fetch')
            mime_type: MIME type (e.g., 'font/woff2', 'image/webp')
            crossorigin: Crossorigin attribute ('anonymous', 'use-credentials')
            fetchpriority: Fetch priority ('high', 'low', 'auto')

        Returns:
            HTML string
        """
        # Try to resolve from assets, fall back to using entry as URL
        url = self.get_asset_url(entry) or entry
        url = self._resolve_url(url)

        attrs = {
            "rel": "preload",
            "href": url,
            "as": as_type,
        }

        if mime_type is not None:
            attrs["type"] = mime_type

        if crossorigin is not None:
            attrs["crossorigin"] = crossorigin

        if fetchpriority is not None:
            attrs["fetchpriority"] = fetchpriority

        return self._build_tag("link", attrs)

    def launch_script(self) -> str:
        """
        Render the Skybolt client launcher.

        Call this once in <head> before other Skybolt assets.
        Outputs config meta tag and client script.

        On first visit (or cache miss), the launcher is inlined with sb-asset
        and sb-url attributes so the client can cache itself.

        On repeat visits (cache hit), returns an external script tag. The Service
        Worker will serve the launcher from cache (~5ms response time).

        Returns:
            HTML string
        """
        sw_path = self._map.get("serviceWorker", {}).get("path", "/skybolt-sw.js")
        config = json.dumps({"swPath": sw_path}, separators=(",", ":"))

        launcher = self._map["launcher"]
        url = self._resolve_url(launcher["url"])

        meta = f'<meta name="skybolt-config" content="{escape(config)}">\n'

        if self._has_cached("skybolt-launcher", launcher["hash"]):
            # Repeat visit - external script (SW serves from cache)
            return f'{meta}<script type="module" src="{escape(url)}"></script>'

        # First visit - inline with sb-asset and sb-url for self-caching
        return (
            f'{meta}<script type="module"'
            f' sb-asset="skybolt-launcher:{escape(launcher["hash"])}"'
            f' sb-url="{escape(url)}">'
            f'{launcher["content"]}'
            f'</script>'
        )

    def get_asset_url(self, entry: str) -> str | None:
        """
        Get URL for an asset (for manual use cases).

        Args:
            entry: Source file path

        Returns:
            Asset URL or None if not found
        """
        url = self._map.get("assets", {}).get(entry, {}).get("url")
        return self._resolve_url(url) if url else None

    def get_asset_hash(self, entry: str) -> str | None:
        """
        Get hash for an asset (for manual use cases).

        Args:
            entry: Source file path

        Returns:
            Asset hash or None if not found
        """
        return self._map.get("assets", {}).get(entry, {}).get("hash")

    def is_cached_url(self, url: str) -> bool:
        """
        Check if an asset URL is currently cached by the client.

        This is useful for Chain Lightning integration where we need to check
        cache status by URL rather than source path.

        Args:
            url: The asset URL (e.g., '/assets/main-Abc123.css')

        Returns:
            True if the asset is cached
        """
        # Build URL to entry mapping if not already built
        if not hasattr(self, "_url_to_entry"):
            self._url_to_entry: dict[str, dict[str, str]] = {}
            for entry, asset in self._map.get("assets", {}).items():
                self._url_to_entry[asset["url"]] = {
                    "entry": entry,
                    "hash": asset["hash"],
                }

        info = self._url_to_entry.get(url)
        if info is None:
            return False

        return self._has_cached(info["entry"], info["hash"])

    def has_cached_entry(self, entry: str, hash_value: str) -> bool:
        """
        Check if client has a specific entry:hash pair cached.

        Useful for external integrations (like Chain Lightning) that manage
        their own assets outside of Skybolt's render-map.

        Args:
            entry: The entry name (e.g., 'chain-lightning' or 'cl-manifest')
            hash_value: The expected hash value

        Returns:
            True if the entry:hash pair is in the client's cache
        """
        return self._has_cached(entry, hash_value)

    def _resolve_url(self, url: str) -> str:
        """Resolve URL with optional CDN prefix."""
        if self._cdn_url is None:
            return url

        # Don't prefix absolute URLs
        if url.startswith(("http://", "https://", "//")):
            return url

        return f"{self._cdn_url}{url}"

    def _has_cached(self, entry: str, hash_value: str) -> bool:
        """Check if client has a specific asset version cached."""
        return self._cache_digest.lookup(f"{entry}:{hash_value}")

    def _build_tag(self, tag: str, attrs: dict[str, str]) -> str:
        """Build an HTML tag."""
        attr_str = " ".join(
            f'{key}="{escape(value)}"' for key, value in attrs.items()
        )
        return f"<{tag} {attr_str}>"

    def _comment(self, text: str) -> str:
        """Generate HTML comment (for errors/debugging)."""
        return f"<!-- {escape(text)} -->"
